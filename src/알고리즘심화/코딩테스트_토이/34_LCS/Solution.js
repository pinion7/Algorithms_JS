const LCS = function (str1, str2) {
  // 기본적으로 두 문자열로 가능한 모든 LCS 경우의 수를 비교는 해야 한다.
  // 그 중 가장 값이 큰 것을 리턴하면 정답이 되겠지만
  // 문제는 비교 과정을 진행과정 중에, 했던 비교를 또 하게되는 일이 발생하게 되면 
  // 시간복잡도가 어마어마하게 증가해서 문제를 해결할 수 없다는 점이 포인트인 것이다.
  // 즉, 결국 이런 상황에서 꺼내들 수 있는 방법은 동적계획법 뿐이다.
  // 이미 했던 연산 혹은 이미 수행했던 과정을 미리 저장해두고 사용할 수 있어야 한다.

  // 1. 우선 LCS 길이를 저장해갈 배열을 하나 선언해준다.
  // 이차원 배열의 형태로 str1의 길이를 행으로, str2의 길이를 열로하는 크기로 만든다.
  // 그럼 모든 경우의 수를 저장할 수 있는 크기가 된다.
  // 구하고자하는 것이 '길이'이기 때문에 i,j가 0인것부터(문자열이 없는 것부터) 마지막 길이까지 저장해가야 한다.
  // 최초의 값은 아직 경우의 수를 체크하지 않았다는 표시를 위해 -1로 채운다.
  const dpLCSLen = [];
  for (let i = 0; i <= str1.length; ++ i) {
    dpLCSLen.push(new Array(str2.length + 1).fill(-1));
  }

  // 2. 각 문자열로 만들 수 있는 모든 길이를 서로 비교해 간다고 가정하고 이중 반복문을 만들어주자.
  // i나 j가 0인 경우는 문자열의 길이가 0이란 뜻이므로 당연히 길이는 0이 저장된다.
  // 만약 둘 중 하나가 0이 아닌 상황에, 현재 비교중인 i, j, 즉 각각의 끝문자열이 서로 같다면
  // 직전에 저장해둔 LCSLen의 값에 +1한 값만큼이 최대 LCS 길이가 될 수밖에 없다.
  // 여기서 주의할 점은 str[i]와 str[j]를 비교하는 것이 아닌 1씩 차감한 위치를 비교한다는 것이다.
  // 기본적으로 i, j는 문자열을 slice했을 때 두번째 인자로 들어가는 값이므로 그 직전이 바로 끝문자열이다. 
  // 만약 끝문자열이 같지 않다면, i가 1작았을때 저장됐던 dpLCSLen값과 j가 1작았을때 저장됐던 dpLCSLen값을
  // 비교하여, 최대 길이를 저장해 주면 된다. 같지 않다면 i,j의 직전 dpLCSLen의 길이 중 하나가 최대일 것이기 때문이다.
  for (let i = 0; i <= str1.length; ++i) {
    for (let j = 0; j <= str2.length; ++j) {
      if (i === 0 || j === 0) dpLCSLen[i][j] = 0;
      else if (str1[i - 1] === str2[j - 1]) {
        dpLCSLen[i][j] = dpLCSLen[i - 1][j - 1] + 1;
      }
      else dpLCSLen[i][j] = Math.max(dpLCSLen[i - 1][j], dpLCSLen[i][j - 1]);
    }
  }
  
  // 3. 결과를 반환하기만 하면 된다. 동적계획법으로 최종 위치에 목표 값이 저장되었을 것이기 때문이다.
  return dpLCSLen[str1.length][str2.length];
}