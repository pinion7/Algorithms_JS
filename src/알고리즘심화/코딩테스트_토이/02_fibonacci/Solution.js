function fibonacci(n) {
  // 분석
  // 피보나치의 경우 일반적인 연산으로는 시간복잡도가 엉망이 되기 쉽다.
  // 값을 누적해두고 이미 존재하는 값은 다시 활용할 수 있어야 한다.
  // for문으로 해결할거라면 tabulation 방식을 사용하고
  // 재귀적으로 접근할 거라면 memoization 방식을 써줘야 한다.
  // 문제 요구사항이 재귀이므로 이에 따라보겠다.
  
  // 풀이
  // 1. 원리는 위에서 말한바와 같다. 저장을 하고 다시 사용한다.
  // 2. 우선 0, 1번 인덱스를 배열에 저장해두고 사용한다.
  // 3. 재귀함수를 구현하고 내부를 탈출조건과 재귀조건으로 나눈다.
  // 4. 저장된 값이면 그대로 리턴, 아니면 연산하여 저장 후 리턴한다.
  const temp = [0, 1];
  
  const aux = (n) => {
      if (temp[n] !== undefined) return temp[n];
      temp[n] = aux(n - 1) + aux(n - 2);
      return temp[n];
  }
  
  return aux(n);
}




