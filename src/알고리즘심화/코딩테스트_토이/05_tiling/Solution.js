
let tiling = function (n) {
  // 풀이 1
  // 경우의 수 구하는 공식을 활용
  // nCr = n! / (n-r)! * r! -> 조합 (순서 상관없이 뽑기만 하는 것)
  // nCr = n! / (n-r)! -> 순열 (뽑으면서 순서까지 다 경우의 수로 처리하는 것)
  // 타일링도 실질적으론 타일이 서로 다른 타일들이 아니라 같은 타일들이라고 할 수 있기 때문에 '조합'
  // 세로는 한개씩 놓일 수 있음. 하지만 가로는 2*n 타일에선 쌍으로 움직여야함. 즉, 가로한쌍 === 세로1개 라고 생각해야 함
  // 2 * n 에서 n이 홀수 일때는 세로 짝수개의 경우가 불가 -> 0회
  // 2 * n 에서 n이 짝수 일때는 세로 홀수개의 경우가 불가 -> 0회
  // 2 * 1 보드 -> 세로 0개 + 세로 1개 = 0 + 1C1 => 1회 
  // 2 * 2 보드 -> 세로 0개 + 세로 1개 + 세로 2개 = 1C0 + 0 + 2C2 => 2회
  // 2 * 3 보드 -> 세로 0개 + 세로 1개 + 세로 2개 + 세로 3개 = 0 + 2C1 + + 0 + 3C3 => 3회
  // 2 * 4 보드 -> 세로 0, 세로 1, 세로 2, 세로 3, 세로 4 = 2C0 + 0 + 3C2 + 0 + 4C4 => 5회
  // 2 * 5 보드 -> 세로 0, 세로 1, 세로 2, 세로 3, 세로 4, 세로 5 = 0 + 3C1 + 0 + 4C3 + 0 + 5C5 => 8회
  
  // 법칙 정리: 공통적으로 nCr에서 n은 1씩 줄고, r은 2씩 줄어듬
  //  ex) 2 * 5보드 -> 5C5 + 4C3 + 3C1
  //  ex) 2 * 4보드 -> 4C4 + 3C2 + 2C0
  // 즉, n이 홀수일 경우 r이 1이 될때까지의 경우만 합산하면 되고
  // n이 짝수일 경우, r이 0이 될때까지의 경우를 합산하면 됨

  // 1. 우선 팩토리얼 함수를 만들어 준다.
  const fac = (n) => {
    if (n <= 1) return 1
    return n * fac(n - 1)
  }

  // 2. 반복문을 통해 r을 차감해간다. (n도 마찬가지)
  // 최초의 r은 n과 같으며, 2씩 줄어들어야 하고, 0보다 더 작아지면 안 된다. (n은 1씩 감소)
  // 결과값을 담을 변수도 만들어 준다.
  let resultVal = 0;
  for (let r = n; r >= 0; r = r - 2) {
    // r이 홀수일 경우 (n은 1씩 줄어드기 때문에 어차피 초기값이 n과 같은 r로 조건문을 짜야한다)
    if (r % 2 === 1 && r >= 1) {
      resultVal += fac(n) / (fac(n-r) * fac(r))
      --n
    } // r이 짝수일 경우
    else if (r % 2 === 0) {
      resultVal += fac(n) / (fac(n-r) * fac(r))
      --n
    }
  }

  return resultVal;
};




